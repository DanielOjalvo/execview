#!/usr/bin/env python3

import os
import sys
import pprint
import argparse
import psycopg2
import configparser

from library import *

# get connection string from config
conn_string = get_conn_str()


def safe_execsql(sql, args = None):
    '''
    Safely execute a SQL statement with exceptions and errors caught and processed. 
    safe_execsql() uses fetchall() to return all results at once.

    @param
    sql     the sql statement
    args    arguments for passing into sql query, MUST BE a tuple; default (None) when no arguments necessary.

    @return
    the result set in a format of list of tuples
    '''

    # check if arguments are given in valid format
    if not isinstance(args, tuple) and args is not None:
        raise Exception("The arguments for sql is not passed with a tuple.")
    
    # establish connection
    conn = psycopg2.connect(conn_string)

    # init variable
    res = []

    # with connect enables auto-commit. (otherwise do conn.commit() manually)
    with conn:
        with conn.cursor() as cur:
            # execute statement
            if args:
                cur.execute(sql, args)
            else:
                cur.execute(sql)
            
            # print real query generated by psycopg2
            print(cur.query)

            try:
                # may have concerns about the elapsed time for each transaction. 
                res = cur.fetchall()
            except psycopg2.ProgrammingError:
                # on error, return empty result set
                res = []

    # close connection
    conn.close()

    return res



def safe_execsql_gen(sql, fetch = 150, args = None):
    '''
    Safely execute a SQL statement with exceptions and errors caught and processed while mitigating memory overhead. 
    safe_execsql_gen() returns a generator object that will yield the given a certain amount of results, which is determined by param fetch, each time.
    Access the result by iterating over this function.

    @param
    sql     the sql statement
    fetch   the rows to fetch every time. fetchmany() helps reduce the memory usage.
    args    arguments for passing into sql query, MUST BE a tuple; default (None) when no arguments necessary.

    @yield
    a generator object that can be used to retrieve a tuple in each iteration
    '''

    # check if arguments are given in valid format
    if not isinstance(args, tuple) and args is not None:
        raise Exception("The arguments for sql is not passed with a tuple.")
    
    if not isinstance(fetch, int):
        raise Exception("The rows to fetch should be a valid integer.")
    
    if fetch <= 0:
        raise Exception("Parameter fetch shall be an integer that is not lesser or equal to zero.")
    
    # establish connection
    conn = psycopg2.connect(conn_string)

    # init variable
    res = []

    # with connect enables auto-commit. (otherwise do conn.commit() manually)
    with conn:
        with conn.cursor() as cur:
            # execute statement
            if args:
                cur.execute(sql, args)
            else:
                cur.execute(sql)
            
            # print real query generated by psycopg2
            print(cur.query)
        
            try:
                # use arraysize instead of size argument of fetchmany() to achieve optimal performance
                cur.arraysize = fetch
                
                while True:
                    res = cur.fetchmany()

                    if not res:
                        break
                    for row in res:
                        yield row

            except psycopg2.ProgrammingError:
                pass

    # close connection
    conn.close()

    # on error, return empty result set
    yield []



def resolve_deps(product, version, debug = True):
    '''
    Update columns in resolved_deps_execs table to store the resolved r_exec_id of a dep_id. 
    This script is designed to run frequently whenever database data are added or modified.

    Note that more than one r_exec_id may be resolved for one dep_id. Since the program does not have enough capability to do more than name matching, incorrect entries must be manually removed by admins.
    '''

    if not debug:
        # insert all entries under certain prod/vers found in execs table that have a name and version/product match with dependencies in deps table
        sql_insert_execs_match = "INSERT INTO resolved_deps_execs(r_exec_id, dep_id) " + \
                                 "SELECT DISTINCT e1.exec_id, d2.dep_id FROM execs e1 " + \
                                 "JOIN rpms r1 ON e1.rpm_id = r1.rpm_id JOIN versions v1 ON r1.vers_id = v1.vers_id JOIN products p1 ON v1.prod_id = p1.prod_id " + \
                                 "JOIN deps d2 ON e1.exec ILIKE concat('%', d2.dep, '%') JOIN execs e2 ON d2.exec_id = e2.exec_id JOIN rpms r2 ON e2.rpm_id = r2.rpm_id JOIN versions v2 ON r2.vers_id = v2.vers_id JOIN products p2 ON v2.prod_id = p2.prod_id " + \
                                 "WHERE v1.vers_id = v2.vers_id AND p1.prod_id = p2.prod_id AND p1.product = %s AND v1.version = %s; "

        
        # insert all entries under certain prod/vers found in aliases table that have a name and version/product match with dependencies in deps table
        sql_insert_aliases_match = "INSERT INTO resolved_deps_execs(r_exec_id, dep_id) " + \
                                   "SELECT DISTINCT e1.exec_id, d2.dep_id FROM aliases a1 " + \
                                   "JOIN execs e1 ON a1.exec_id = e1.exec_id JOIN rpms r1 ON e1.rpm_id = r1.rpm_id JOIN versions v1 ON r1.vers_id = v1.vers_id JOIN products p1 ON v1.prod_id = p1.prod_id " + \
                                   "JOIN deps d2 ON a1.alias ILIKE concat('%', d2.dep, '%') JOIN execs e2 ON d2.exec_id = e2.exec_id JOIN rpms r2 ON e2.rpm_id = r2.rpm_id JOIN versions v2 ON r2.vers_id = v2.vers_id JOIN products p2 ON v2.prod_id = p2.prod_id " + \
                                   "WHERE v1.vers_id = v2.vers_id AND p1.prod_id = p2.prod_id AND p1.product = %s AND v1.version = %s; "
        
        # execute queries to insert
        safe_execsql(sql_insert_execs_match, (product, version))
        safe_execsql(sql_insert_aliases_match, (product, version))

    # debug set to True: step-by-step processing
    else:
        # select all entries under certain prod/vers found in execs table that have a name and version/product match with dependencies in deps table
        sql_select_execs_match = "SELECT DISTINCT e1.exec_id, d2.dep_id FROM execs e1 " + \
                                 "JOIN rpms r1 ON e1.rpm_id = r1.rpm_id JOIN versions v1 ON r1.vers_id = v1.vers_id JOIN products p1 ON v1.prod_id = p1.prod_id " + \
                                 "JOIN deps d2 ON e1.exec ILIKE concat('%%', d2.dep, '%%') JOIN execs e2 ON d2.exec_id = e2.exec_id JOIN rpms r2 ON e2.rpm_id = r2.rpm_id JOIN versions v2 ON r2.vers_id = v2.vers_id JOIN products p2 ON v2.prod_id = p2.prod_id " + \
                                 "WHERE v1.vers_id = v2.vers_id AND p1.prod_id = p2.prod_id AND p1.product = %s AND v1.version = %s; "

        
        # select all entries under certain prod/vers found in aliases table that have a name and version/product match with dependencies in deps table
        sql_select_aliases_match = "SELECT DISTINCT e1.exec_id, d2.dep_id FROM aliases a1 " + \
                                   "JOIN execs e1 ON a1.exec_id = e1.exec_id JOIN rpms r1 ON e1.rpm_id = r1.rpm_id JOIN versions v1 ON r1.vers_id = v1.vers_id JOIN products p1 ON v1.prod_id = p1.prod_id " + \
                                   "JOIN deps d2 ON a1.alias ILIKE concat('%%', d2.dep, '%%') JOIN execs e2 ON d2.exec_id = e2.exec_id JOIN rpms r2 ON e2.rpm_id = r2.rpm_id JOIN versions v2 ON r2.vers_id = v2.vers_id JOIN products p2 ON v2.prod_id = p2.prod_id " + \
                                   "WHERE v1.vers_id = v2.vers_id AND p1.prod_id = p2.prod_id AND p1.product = %s AND v1.version = %s; "
        

        # insert a single row of data entry (takes 4 params)
        sql_insert_match_single = "INSERT INTO resolved_deps_execs(r_exec_id, dep_id) SELECT %s, %s " + \
                                  "WHERE NOT EXISTS (SELECT * FROM resolved_deps_execs WHERE r_exec_id = %s AND dep_id = %s) RETURNING *;"
        
        try:
            for tup in safe_execsql_gen(sql_select_execs_match, 100, (product, version)):
                # if no result returned, tup will be []
                if tup:           
                    insert_success = safe_execsql(sql_insert_match_single, tup + tup)

                    # results will return on success
                    if insert_success:
                        # console log
                        terminal_msg(2, "r_exec_id %d has been inserted for dep_id %d." % (insert_success[0][0], insert_success[0][1]))

            for tup in safe_execsql_gen(sql_select_aliases_match, 100, (product, version)):
                # if no result returned, tup will be []
                if tup:
                    insert_success = safe_execsql(sql_insert_match_single, tup + tup)

                    # results will return on success
                    if insert_success:
                        # console log
                        terminal_msg(2, "r_exec_id %d has been inserted for dep_id %d." % (insert_success[0][0], insert_success[0][1]))

        # Overall Exception handler for database access                   
        except (Exception, KeyboardInterrupt) as e:
            utility.terminal_msg(1, "Exception/Interrupt {} caught during database processing static dependencies. Please manually re-run dep_resolver for version {} or for all (-a) option.".format(e, version))
            utility.terminal_msg(0, "Program unexpectedly terminated.")
       
    

def resolve_deps_complete():
    # insert all entries found in execs table that have a name and version/product match with dependencies in deps table
    sql_insert_execs_match = "INSERT INTO resolved_deps_execs(r_exec_id, dep_id) " + \
                                "SELECT DISTINCT e1.exec_id, d2.dep_id FROM execs e1 " + \
                                "JOIN rpms r1 ON e1.rpm_id = r1.rpm_id JOIN versions v1 ON r1.vers_id = v1.vers_id JOIN products p1 ON v1.prod_id = p1.prod_id " + \
                                "JOIN deps d2 ON e1.exec ILIKE concat('%', d2.dep, '%') JOIN execs e2 ON d2.exec_id = e2.exec_id JOIN rpms r2 ON e2.rpm_id = r2.rpm_id JOIN versions v2 ON r2.vers_id = v2.vers_id JOIN products p2 ON v2.prod_id = p2.prod_id " + \
                                "WHERE v1.vers_id = v2.vers_id AND p1.prod_id = p2.prod_id; "


    # insert all entries found in aliases table that have a name and version/product match with dependencies in deps table
    sql_insert_aliases_match = "INSERT INTO resolved_deps_execs(r_exec_id, dep_id) " + \
                                "SELECT DISTINCT e1.exec_id, d2.dep_id FROM aliases a1 " + \
                                "JOIN execs e1 ON a1.exec_id = e1.exec_id JOIN rpms r1 ON e1.rpm_id = r1.rpm_id JOIN versions v1 ON r1.vers_id = v1.vers_id JOIN products p1 ON v1.prod_id = p1.prod_id " + \
                                "JOIN deps d2 ON a1.alias ILIKE concat('%', d2.dep, '%') JOIN execs e2 ON d2.exec_id = e2.exec_id JOIN rpms r2 ON e2.rpm_id = r2.rpm_id JOIN versions v2 ON r2.vers_id = v2.vers_id JOIN products p2 ON v2.prod_id = p2.prod_id " + \
                                "WHERE v1.vers_id = v2.vers_id AND p1.prod_id = p2.prod_id; "
    
    # execute queries to insert
    safe_execsql(sql_insert_execs_match)
    safe_execsql(sql_insert_aliases_match)

    ''' approaches that always do a full update (even on existed r_exec_id)
    # only for postgres 9.5+
    
    # do a full table insert on whatever executable name matches the substring of dep name.
    # if r_exec_id exist, overwrite it.
    sql_insert_like_execs = "INSERT INTO deps (dep_id, r_exec_id) " + \
                            "   SELECT d.dep_id, e.exec_id FROM deps d " + \
                            "   JOIN execs e ON e.exec ilike concat('%', d.dep, '%')" + \
                            " " + \
                            "ON CONFLICT (dep_id)" + \
                            "DO UPDATE SET r_exec_id = EXCLUDED.r_exec_id; "

    # do a full table insert on whatever alias name matches the substring of dep name
    # if r_exec_id exist, do nothing. (executable name match should be preferred over alias name match)
    sql_insert_like_aliases = "INSERT INTO deps (dep_id, r_exec_id) " + \
                              "   SELECT d.dep_id, e.exec_id FROM deps d " + \
                              "   JOIN aliases a ON a.alias ilike concat('%', d.dep, '%')" + \
                              " " + \
                              "ON CONFLICT (dep_id)" + \
                              "DO NOTHING  "
    

    # stucking on execution for unknown reason
    sql_update_join_alias = "UPDATE deps SET r_exec_id = aliases.exec_id FROM aliases WHERE aliases.alias ilike concat('%', deps.dep, '%')"
    sql_update_join_exec = "UPDATE deps SET r_exec_id = execs.exec_id FROM execs WHERE execs.exec ilike concat('%', deps.dep, '%')"
    '''


if __name__ == "__main__":

    p = argparse.ArgumentParser()

    p.add_argument("-p", "--product-name", metavar = "<BIG-IP/BIG-IQ/..>", type = str,
                    help = "The name of the product to examine. MUST be specified with exact name.")
    p.add_argument("-v", "--version-number", metavar = "<x.x.x.x-#.#.#>", type = str,
                    help = "The version number, including the release number, of the product to examine. MUST be specified with exact number.")
    p.add_argument("-a", "--all", action = "store_true",
                    help = "Resolve all existed products/versions in database.")
    args = p.parse_args()

    # execute
    if args.all:
        resolve_deps_complete()
    elif args.product_name and args.version_number:
        resolve_deps(args.product_name, args.version_number)
    else:
        terminal_msg(1, "Please use -h to check the usage")
