#!/usr/bin/env python3

'''
designed for cronjobs where /build and /sources are mount on the system.
They need to be mounted under the same parent directory.
e.g. /mnt/seadev/build for /build
     /mnt/seadev/sources for /sources
'''
import psycopg2
import argparse
import re
import os
import sys
import inspect
import traceback
sys.path.append(os.path.dirname( os.path.abspath( inspect.getfile( inspect.currentframe() ) ) ) + '/dynamic/')
sys.path.append(os.path.dirname( os.path.abspath( inspect.getfile( inspect.currentframe() ) ) ) + '/static/')
sys.path.append(os.path.dirname( os.path.abspath( inspect.getfile( inspect.currentframe() ) ) ) + '/library/')

import dynamic_parser
import static_parser
import dependency_resolver
from library import *


def get_fullversion_str(dynamic_path, version):
    #import pdb; pdb.set_trace()
    # bldnum file approach
    fullver_str = ""
    try:
        with open(dynamic_path + "/bldnum", "r") as f:
            # read the raw string form bldnum (e.g., 3754.0)
            buildnum_raw = f.readline().strip()
            # match with regex (just in case there are other unwanted info appended)
            bn_regex = r"(\d+).0"
            bn_regex_match = re.search(bn_regex, buildnum_raw)
            # form the build number. (e.g., 3754.0 => 0.0.3754)
            build_bldnum = "0.0." + bn_regex_match.group(1)
            print("DHNO: Reached here when getting re")
            # version: hotfix processing 
            if "-hf" in version:
                version = version.split("-hf", 1)[0]

                # ISO filename extract approach
            for f in os.listdir(dynamic_path):
                # find the ISO
                #print("DHNO: listing directory")
                #print("DHNO: f is", f)
                if os.path.splitext(f)[-1].lower() == ".iso":
                    # define the regex to match version + buildnum
                    fn_regex = r"(" + version + r"[-.](.+?)).iso"
                    fn_regex_match = re.search(fn_regex, f)


                    print(fn_regex_match.groups())
                    fullver_str = fn_regex_match.group(1)
                    # build number from ISO
                    build_isoname = fn_regex_match.group(2)

                    # complain on mismatch, proceed with build numbers in ISO filename
                    if build_isoname != build_bldnum:
                        utility.terminal_msg(1, "Either the build number in bldnum is incorrect or the build serializing is not following the standard fashion. " + \
                                         "\n\t bldnum: {0} ; ISO filename: {1}".format(buildnum_raw, build_isoname))
    except FileNotFoundError as e:
        print("Error in finding dynamic path bldnum.")
        print(e.strerror)
        fullver_str = ""
        
    return fullver_str
        


def version_exist(prod, vers):
    # establish connection
    conn = psycopg2.connect(utility.get_conn_str())

    # init variable
    res = (0,)

    # with connect enables auto-commit. (otherwise do conn.commit() manually)
    with conn:
        with conn.cursor() as cur:
            sql = "SELECT count(*) FROM versions JOIN products ON versions.prod_id = products.prod_id WHERE products.product = '{}' AND versions.version = '{}';".format(prod, vers + "%")
            cur.execute(sql)
            
            # print real query generated by psycopg2
            print(cur.query)

            try:
                res = cur.fetchone()
            except psycopg2.ProgrammingError:
                res = (0,) # Error
    
    # close connection
    conn.close()

    try:
        if res[0] > 0:
            utility.terminal_msg(2, "Product %s %s is already parsed into database.".format(prod, vers))
            return True
        # when certain version not found in database
        else:
            return False
    except Exception as e:
        utility.terminal_msg(0, "Error occurred during querying product %s %s with error message: %s".format(prod, vers, e))
                    
    

def iterate_seadev(args):

    # add/edit paths here for new products supported or on change of seadev directory structure

    # retrieve mount point
    mnt_path = args.seadev

    # Only add this many isos to the database
    iso_load_limit = args.limit_upload
    isos_uploaded = 0

    # check if the mount point exists or not 
    # add os.path.ismount(mnt_path) check when PD figures out a way to mount / (currently impossible with CIFS as well due to different access policies imposed to different subdirs)
    if os.path.isdir(mnt_path): 
        mnt_path = utility.dir_formatting(mnt_path)
    else:
        utility.terminal_msg(0, "Mount point not found or not a valid one.")

    # iterate over all products specified in path_dict
    for prod in path_dict:
        dynamic_base_path = mnt_path + "/build/" + path_dict.get(prod)
        dynamic_trailing_path =  "dist/release"

        # check if path provided can be found in file system
        if os.path.exists(dynamic_base_path) and os.path.isdir(dynamic_base_path):
            # iterate over all versions
            for ver_dir in os.listdir(dynamic_base_path):

                # form the complete path for dynamic parsing
                dynamic_path = os.path.join(dynamic_base_path, ver_dir, dynamic_trailing_path)

                # check if build path exist
                if os.path.exists(dynamic_path) and os.path.isdir(dynamic_path):

                    static_base_path = mnt_path + "/sources/" + path_dict.get(prod)
                    static_trailing_path = "release/logs"

                    # form the complete path for static parsing
                    static_path = os.path.join(static_base_path, ver_dir, static_trailing_path)

                    # set product
                    args.product_name = prod
                    # remove the "v" from the directory name and set version. (e.g., v13.1.1 => version number 13.1.1)
                    #args.version_number = get_fullversion_str(dynamic_path, ver_dir[1:])
                    args.version_number = ver_dir[1:]

                    # if no version number found (due to no iso found), skip

                    if not args.version_number:
                        continue
                    try:
                         # check if sources path also exist and whether the version is seen in DB
                        if os.path.exists(static_path) and os.path.isdir(static_path) and not version_exist(args.product_name,
                                                                                                            args.version_number):
                            if (iso_load_limit and (isos_uploaded >= iso_load_limit)):
                                #We've uploaded enough isos for now. Time to break out
                                break
                            isos_uploaded += 1
                             # log message
                            utility.terminal_msg(2, "Processing {} {} from seadev path.".format(args.product_name, args.version_number))
                            # run parser
                            args = dynamic_parser.wrapper(args, 2)
                            static_parser.wrapper(args, 2)
                            dependency_resolver.resolve_deps(args.product_name, args.version_number)
                    except Exception as e:
                        with open("~/parser_exception_log", "a") as f:
                            f.write("************FOUND EXCEPTION**********\n")
                            f.write("Error parsing version: %s\n" % args.version_number)
                            f.write("Static path calculated %s\n" % os.fsdecode(args.static_path))
                            f.write("Dynamic path %s\n" % os.fsdecode(dynamic_path))
                            exc_type, exc_value, exc_traceback = sys.exc_info()
                            traceback.print_tb(exc_traceback, file=sys.stdout)

                            traceback.print_exception(exc_type, exc_value, exc_traceback, file=f)
                        continue
                            

 
    terminal_msg(2, "Completed uploading {} isos to {} at {}.".format(args.isos_uploaded, utility.get_database_name(), utility.get_database_url()))

if __name__ == "__main__":
    p = argparse.ArgumentParser()

    # used
    p.add_argument("-pc", "--processes", metavar="<amount>", type=int, default=5,
                    help = "The number of processes to spawn that can be utilized to examine rpm files. " + \
                        "(default 10, suggested threshold x where x <= how many GBs of RAM available)")
    p.add_argument("-o", "--output-directory", metavar = "<path>", type = str, default = "./output/",
                    help = "A directory to place the output. <cwd>/output is created if not specified.")

    p.add_argument("-sd", "--seadev", metavar = "<mount path>", type = str, required = True,
                    help = "The mount point if running on or mounted with the seadev machine or any UNIX box that shares the same source code/ISO directory structure as seadev.")
                   
    p.add_argument("-c", "--clean-output-directory", action = "store_true",
                   help = "Cleanup the output directory before writing to it.")
    p.add_argument("-w", "--wipe-program-output", action = "store_true",
                   help = "Remove the output directories and files after the whole process finishes.")
    p.add_argument("-l", "--limit-upload", metavar="<limit>", type=int, default=0,
                   help = "Only upload <limit> new isos to the database.")

    # not used, but necessary for compatibility with dynamic/static parsers
    p.add_argument("-i", "--iso", type=str,
                    help = "[*] Please do not assign any value. This option will not take affect in this script.")
    p.add_argument("-d", "--directory", type=str,
                    help = "[*] Please do not assign any value. This option will not take affect in this script.")
    p.add_argument("-f", "--file", type = str,
                    help = "[*] Please do not assign any value. This option will not take affect in this script.")
    p.add_argument("-p", "--product-name", type = str,
                    help = "[*] Please do not assign any value. This option will not take affect in this script.")
    p.add_argument("-v", "--version-number", type = str,
                    help = "[*] Please do not assign any value. This option will not take affect in this script.")
 
    
    args = p.parse_args()
    args.isos_uploaded = 0
    iterate_seadev(args)
    
